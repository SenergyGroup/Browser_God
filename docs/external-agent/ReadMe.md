# External Agent Messaging Interface

This document describes how a locally hosted agent (Python script, Node.js application, or Django service) can communicate with the Browser God extension through an approved messaging channel.

The agent itself is out of scope for this ticket, but the interface defined here is stable and mirrors the exact messages generated by the popup's internal test trigger. Any agent that follows this contract will interoperate with the service worker.

## Overview

* Messages travel through standard Chrome extension messaging channels. Depending on the host platform, the agent may use:
  * A content script bridge that relays `window.postMessage` events to the extension.
  * A lightweight companion extension that proxies `chrome.runtime.sendMessage` calls.
  * Chrome Native Messaging to reach the service worker from a local executable.
* The transport will be chosen in a follow-up ticket. Regardless of the transport, the JSON payloads documented below are required.
* The service worker only executes commands when **Agent control** is enabled in the popup. Agents must either instruct users to enable it or send a `toggleAgentControl` request before issuing commands.

## Sending commands (`enqueueCommand`)

Agents enqueue work by sending the following message to the extension runtime:

```json
{
  "type": "enqueueCommand",
  "command": {
    "id": "string",              // Required. Globally unique per command.
    "type": "OPEN_URL",          // Required. One of the supported command types.
    "payload": {                   // Required. Command-specific payload.
      "url": "https://www.etsy.com/",
      "actions": [
        {
          "type": "WAIT",
          "payload": { "milliseconds": 1500 }
        },
        {
          "type": "CAPTURE_JSON_FROM_DEVTOOLS",
          "payload": { "waitForMs": 2000, "closeTab": true }
        }
      ]
    }
  }
}
```

### Command object requirements

* `id` must be unique for every command. The popup uses `crypto.randomUUID()` when generating IDs (e.g. `popup-test-<uuid>`).
* `type` must match one of the service worker command handlers: `OPEN_URL`, `WAIT`, `SCROLL_TO_BOTTOM`, `CLICK`, `CAPTURE_JSON_FROM_DEVTOOLS`, or `EXTRACT_SCHEMA`.
* `payload` contents vary by command type:
  * `OPEN_URL` requires a `url` property. Optional `actions` can contain follow-up commands to run within the opened tab. Each action inherits the tab ID automatically.
  * `WAIT` expects `milliseconds` (defaults to 1000 if omitted).
  * `CAPTURE_JSON_FROM_DEVTOOLS` can specify `waitForMs` and `closeTab` (defaults to `true`).
  * Other commands follow the payload structure used in the existing codebase.
* Commands targeting remote URLs must comply with the `allowedOrigins` setting (Etsy domains by default).

### Immediate response

The service worker immediately acknowledges each request with:

```json
{ "ok": true, "result": { "status": "queued" } }
```

Failures return `{ "ok": false, "error": "REASON" }`. Agents should treat any non-`ok` response as a failure and avoid retrying until the issue is resolved (e.g. agent control disabled, rate limiting, or domain not allowed).

## Receiving results (`commandResult`)

When a command completes (successfully or otherwise), the service worker broadcasts a message:

```json
{
  "type": "commandResult",
  "commandId": "string",   // Matches the original command.id
  "result": {
    "status": "completed", // or "failed", "rejected"
    "errorCode": null,      // Populated when status is "failed" or "rejected"
    "records": []           // Present when data capture produced records
  }
}
```

Agents should listen for this broadcast through the same transport channel used to send commands and correlate results with the original command IDs.

## State management helpers

The service worker exposes additional message types that agents may call:

* `getExtensionState` → returns the latest queue, processing flag, and recent logs.
* `toggleAgentControl` → updates the `agentControlEnabled` flag. Payload: `{ "type": "toggleAgentControl", "enabled": true }`.
* `exportData` → triggers NDJSON export of captured records. Returns `{ "ok": true }` when successful.

These messages use the same asynchronous reply pattern as `enqueueCommand` and are safe to call from external agents.

## Compatibility guarantee

* The popup's **Run test command** button issues a real `enqueueCommand` message using the schema above. Observing its traffic (via extension logs) provides a working reference implementation.
* Future agents must send identical payloads to ensure consistent behavior.
* The service worker logs every incoming message type and never leaves the response channel unresolved for recognized messages, preventing `Could not establish connection` errors.

